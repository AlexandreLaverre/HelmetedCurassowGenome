#! /usr/bin/env python

# Execute via run_Snakemake.sh or with following command :
# snakemake -j 100 --config Prefix=${Prefix} minAlign=0.75 NbPart=${NbPart} Cluster=${Cluster} --rerun-incomplete --cluster "sbatch -p normal -N 1 -o /beegfs/data/alaverre/HelmetedCurassowGenome/scripts/protein_acceleration/log/slurm.out_${Prefix} -e /beegfs/data/alaverre/HelmetedCurassowGenome/scripts/protein_acceleration/log/slurm.err_${Prefix} -c {params.threads} --mem={params.mem} -t {params.time}"

Prefix = config["Prefix"]
minAlign = float(config["minAlign"])
NbPart = int(config["NbPart"])
Cluster = config["Cluster"]

###################################################################################################

if Cluster == "cloud":
    path = "/mnt/mydatalocal/IPLOSS"
    localrules: all, SplitBed,DropShort_Fasta2Phylip, PruneTrees, phyML, CombineTrees
else:
    path = "/beegfs/data/alaverre/Helme"
    PathPython = "/beegfs/data/soft/bioconda/bin/python"
    PathR = "/beegfs/data/soft/R-3.5.2/bin/Rscript"
    localrules: all, SplitBed, DropShort_Fasta2Phylip, phyML, PruneTrees, CombineTrees

pathScripts = path + "/scripts/protein_acceleration"
pathResults = path + "/results/protein_acceleration/" + Prefix

pathData = "/beegfs/data/necsulea/HelmetedCurassowGenome/results/coding_gene_evolution/all_species/"
SpeciesTree = pathData + Prefix + "/species_tree.txt"
pathAlign = pathData + Prefix + "/translated_alignments/"

workdir: pathResults

###################################################################################################
rule all:
    input :
        expand(pathScripts + "/log/" + Prefix + "/part{ID_part}_CombineTrees_done", ID_part=range(100,(100+NbPart)))

rule SplitBed:
    message: "Make several lists of pairs to parallelize from the Interest File"
    input: pathAlign = pathAlign
    output: IDList = pathResults+ "/IDLists/" + Prefix + "_part{ID_part}.txt"
    shell:
        """
        mkdir -p {pathResults}/IDLists/
        find {input.pathAlign} -name *fas | sed 's!.*/!!' | sed 's/.aln.best.fas//g' | head -n 20 > {pathResults}/IDLists/{Prefix}.txt
        split -d -n l/{NbPart} --additional-suffix=.txt {pathResults}/IDLists/{Prefix}.txt {pathResults}/IDLists/{Prefix}_part1
        touch {output.IDList}
        """

rule DropShort_Fasta2Phylip:
    message: "Discard sequences with an alignment size lower than {minAlign} %"
    input:
        IDList = pathResults+ "/IDLists/" + Prefix + "_part{ID_part}.txt"
    output:
        FilteredAlign = directory(pathResults + "/FilteredAlign/" + Prefix + "_part{ID_part}/"),
        CountSeq= pathResults + "/Count_by_species/" + Prefix + "_part{ID_part}_FilteredAlign.txt",
        Done = pathScripts + "/log/" + Prefix + "/part{ID_part}_DropShorts_done"
    params: time="5:00:00", mem="5G", threads="1"
    shell:
        """
        mkdir -p {output.FilteredAlign}
        {PathPython} {pathScripts}/filter_alignment_phyML.py {pathAlign} {input.IDList} {pathResults} {minAlign}
        touch {output.CountSeq}
        touch {output.Done} 
        """

rule PruneTrees:
    message: "Prune the Species Tree to match the corresponding remaining species in each alignment"
    input:
        IDList = pathResults+ "/IDLists/" + Prefix + "_part{ID_part}.txt",
        FilteredAlign= pathResults + "/FilteredAlign/" + Prefix + "_part{ID_part}/"
    output:
        TreeByElem = directory(pathResults + "/SpeciesTrees/" + Prefix + "_part{ID_part}/"),
        Done = pathScripts + "/log/" + Prefix + "/part{ID_part}_PruneTrees_done"
    params: time = "20:00:00", mem = "1G", threads = "1"
    shell:
        """
        mkdir -p {output.TreeByElem}
        for ID in `cat {input.IDList}`
        do
        export species=`cut -f 1 -d " " {input.FilteredAlign}/${{ID}}.rphylip | grep "_" | tr "\n" " " `
        export len=${{#species[@]}}
        gotree prune -r -i {SpeciesTree} -o {output.TreeByElem}/${{ID}}.nh ${{species}}
        done
        touch {output.Done} 
        """

rule phyML:
    message: "Run phyML for filtered phylip and corresponding species tree."
    input:
        IDList=pathResults + "/IDLists/" + Prefix + "_part{ID_part}.txt",
        FilteredAlign= pathResults + "/FilteredAlign/" + Prefix + "_part{ID_part}/",
        TreeByElem = pathResults + "/SpeciesTrees/" + Prefix + "_part{ID_part}/",
        PruneTreesDone = pathScripts + "/log/" + Prefix + "/part{ID_part}_PruneTrees_done"
    output:
        PathphyML = directory(pathResults + "/phyML/" + Prefix + "_part{ID_part}/"),
        phyMLOutput = pathScripts + "/log/phyML_output/" + Prefix + "_part{ID_part}.txt",
        Done = pathScripts + "/log/" + Prefix + "/part{ID_part}_phyML_done"
    params: time="48:00:00", mem="5G",threads="1"
    shell:
        """
        mkdir -p {output.PathphyML}
        mkdir -p {pathScripts}/log/phyML_output/
        for ID in `cat {input.IDList}`
        do
        phyml --datatype aa --quiet --model LG -o lr --input {input.FilteredAlign}/${{ID}}.rphylip --inputtree {input.TreeByElem}/${{ID}}.nh &> {output.phyMLOutput}
        mv {input.FilteredAlign}/${{ID}}*phyml* {output.PathphyML}
        done
        touch {output.Done} 
        """

rule CombineTrees:
    message: "Merge all phyML resulting tree for RERconverge input"
    input:
        PathphyML = pathResults + "/phyML/" + Prefix + "_part{ID_part}/",
        phyMLDone = pathScripts + "/log/" + Prefix + "/part{ID_part}_phyML_done"
    output:
        CombinedTrees = pathResults + "/phyML/" + Prefix + "_part{ID_part}_CombineTrees.txt",
        Done = pathScripts + "/log/" +   Prefix + "/part{ID_part}_CombineTrees_done"
    shell:
        """
        touch {output.CombinedTrees}
        for file in `ls {input.PathphyML}/*tree*`
        do
	    export ID=$(basename ${{file%.rphylip*}})
	    export tree=`cat ${{file}}`
	    echo -e ${{ID}}"\t"${{tree}} >> {output.CombinedTrees}
        done
        touch {output.Done} 
        """

