#! /usr/bin/env python

# Execute via run_Snakemake.sh or with following command :
# snakemake -j 100 --config Prefix=${Prefix} minAlign=0.75 NbPart=${NbPart} Cluster=${Cluster} --rerun-incomplete --cluster "sbatch -p normal -N 1 -o /beegfs/data/alaverre/HelmetedCurassowGenome/scripts/protein_acceleration/log/slurm.out_${Prefix} -e /beegfs/data/alaverre/HelmetedCurassowGenome/scripts/protein_acceleration/log/slurm.err_${Prefix} -c {params.threads} --mem={params.mem} -t {params.time}"

Prefix = config["Prefix"]
minAlign = float(config["minAlign"])
NbPart = int(config["NbPart"])
Cluster = config["Cluster"]

###################################################################################################

if Cluster == "cloud":
    path = "/mnt/mydatalocal/IPLOSS"
    localrules: all, SplitBed, GetAlignments, HmmCleaner, Gblocks, DropShort_Fasta2Phylip, PruneTrees, phyML, CombineTrees
else:
    path = "/beegfs/data/alaverre/HelmetedCurassowGenome"
    PathPython = "/beegfs/data/soft/bioconda/bin/python"
    PathR = "/beegfs/data/soft/R-3.5.2/bin/Rscript"
    localrules: all, SplitBed, GetAlignments, DropShort_Fasta2Phylip, CombineTrees

pathScripts = path + "/scripts/protein_acceleration"
pathResults = path + "/results/protein_acceleration/" + Prefix

pathData = "/beegfs/data/necsulea/HelmetedCurassowGenome/results/coding_gene_evolution/all_species/"
SpeciesTree = pathData + Prefix + "/species_tree.txt"
pathAlign = pathData + Prefix + "/translated_alignments/"

workdir: pathResults

###################################################################################################
rule all:
    input :
        expand(pathScripts + "/log/" + Prefix + "/part{ID_part}_CombineTrees_done", ID_part=range(100,(100+NbPart)))

#pathScripts + "/log/" + Prefix + "/part{ID_part}_CombineTrees_done"
rule SplitBed:
    message: "Make several lists of pairs to parallelize from the Interest File"
    input: pathAlign = pathAlign
    output: IDList = pathResults+ "/IDLists/" + Prefix + "_part{ID_part}.txt"
    shell:
        """
        mkdir -p {pathResults}/IDLists/
        find {input.pathAlign} -name *fas | sed 's!.*/!!' | sed 's/.aln.best.fas//g' > {pathResults}/IDLists/{Prefix}.txt
        split -d -n l/{NbPart} --additional-suffix=.txt {pathResults}/IDLists/{Prefix}.txt {pathResults}/IDLists/{Prefix}_part1
        touch {output.IDList}
        """

rule GetAlignments:
    message: "Copy alignment from original folder for HMMCleaner"
    input: IDList = pathResults+ "/IDLists/" + Prefix + "_part{ID_part}.txt"
    output:
        Align = directory(pathResults + "/Alignments/" + Prefix + "_part{ID_part}/"),
        Done = pathScripts + "/log/" + Prefix + "/part{ID_part}_GetAlign_done"
    shell:
        """
        mkdir -p {output.Align}
        while read -r line;
        do
        cp {pathAlign}/${{line}}.aln.best.fas {output.Align};
        done < {input.IDList}
        touch {output.Done} 
        """

rule HmmCleaner:
    message: "Clean alignments with HMMCleaner"
    input:
        AlignDone = pathScripts + "/log/" + Prefix + "/part{ID_part}_GetAlign_done",
        AlignPath = pathResults + "/Alignments/" + Prefix + "_part{ID_part}/"
    output: touch(pathScripts + "/log/" + Prefix + "/part{ID_part}_HmmCleaner_done")
    log: pathScripts + "/log/" + Prefix + "/part{ID_part}_HmmCleaner_output"
    params: time="5:00:00",mem="1G",threads="1"
    singularity: "/beegfs/home/tricou/singularity_image/hmm.sif"
    shell:
        """
        cd {input.AlignPath}
        export AlignList=`ls *.fas`
        HmmCleaner.pl ${{AlignList}} &> {log}
        """

rule Gblocks:
    message: "Clean alignments with Gblocks"
    input:
        IDList=pathResults + "/IDLists/" + Prefix + "_part{ID_part}.txt",
        AlignDone=pathScripts + "/log/" + Prefix + "/part{ID_part}_HmmCleaner_done",
        AlignPath=pathResults + "/Alignments/" + Prefix + "_part{ID_part}/"
    output: touch(pathScripts + "/log/" + Prefix + "/part{ID_part}_Gblocks_done")
    log: pathScripts + "/log/" + Prefix + "/part{ID_part}_Gblocks_output"
    params: time="5:00:00",mem="1G",threads="1"
    shell:
        """
        for ID in `cat {input.IDList}`
        do 
        {PathPython} {pathScripts}/Gblocks.py {input.AlignPath}/${{ID}}.aln.best_hmm.fasta --t=p --b1=51 --b2=70 --b3=10 --b4=2 --b5=a &> {log}
        done
        """

rule DropShort_Fasta2Phylip:
    message: "Discard sequences with a proportion of GAP >= {minAlign}"
    input:
        CleanDone = pathScripts + "/log/" + Prefix + "/part{ID_part}_Gblocks_done",
        IDList = pathResults+ "/IDLists/" + Prefix + "_part{ID_part}.txt",
        AlignPath= pathResults + "/Alignments/" + Prefix + "_part{ID_part}/"
    output:
        FilteredAlign = directory(pathResults + "/FilteredAlign/" + Prefix + "_part{ID_part}/"),
        CountSeq= pathResults + "/Count_by_species/" + Prefix + "_part{ID_part}_FilteredAlign.txt",
        Done = pathScripts + "/log/" + Prefix + "/part{ID_part}_DropShorts_done"
    params: time="5:00:00", mem="1G", threads="1"
    shell:
        """
        mkdir -p {output.FilteredAlign}
        {PathPython} {pathScripts}/filter_alignment_phyML.py {input.AlignPath} {input.IDList} {pathResults} {minAlign}
        touch {output.CountSeq}
        touch {output.Done} 
        """

rule PruneTrees:
    message: "Prune the Species Tree to match the corresponding remaining species in each alignment"
    input:
        IDList = pathResults+ "/IDLists/" + Prefix + "_part{ID_part}.txt",
        FilteredAlign= pathResults + "/FilteredAlign/" + Prefix + "_part{ID_part}/"
    output:
        TreeByElem = directory(pathResults + "/SpeciesTrees/" + Prefix + "_part{ID_part}/"),
        Error = pathScripts + "/log/" + Prefix + "/part{ID_part}_PruneTrees_error.txt",
        Done = pathScripts + "/log/" + Prefix + "/part{ID_part}_PruneTrees_done"
    params: time = "5:00:00", mem = "1G", threads = "1"
    shell:
        """
        mkdir -p {output.TreeByElem}
        for ID in `cat {input.IDList}`
        do
        export species=`cut -f 1 -d " " {input.FilteredAlign}/${{ID}}.rphylip | grep "_" | tr "\n" " " `
        export len=`cut -f 1 -d " " {input.FilteredAlign}/${{ID}}.rphylip | grep "_" -c `
	    
	    # Excluding alignment with less than 4 sequences
	    touch {output.Error}
        if (( ${{len}} < 4 ))
        then
        echo ${{ID}} >> {output.Error}
        grep -v ${{ID}} {input.IDList} > {input.IDList}2
        mv {input.IDList}2 {input.IDList}
        
        else
        gotree prune -r -i {SpeciesTree} -o {output.TreeByElem}/${{ID}}.nh ${{species}}
        fi
        done
        touch {output.Done} 
        """

rule phyML:
    message: "Run phyML for filtered phylip and corresponding species tree."
    input:
        IDList=pathResults + "/IDLists/" + Prefix + "_part{ID_part}.txt",
        FilteredAlign= pathResults + "/FilteredAlign/" + Prefix + "_part{ID_part}/",
        TreeByElem = pathResults + "/SpeciesTrees/" + Prefix + "_part{ID_part}/",
        PruneTreesDone = pathScripts + "/log/" + Prefix + "/part{ID_part}_PruneTrees_done"
    output:
        PathphyML = directory(pathResults + "/phyML/" + Prefix + "_part{ID_part}/"),
        phyMLOutput = pathScripts + "/log/phyML_output/" + Prefix + "_part{ID_part}.txt",
        Done = pathScripts + "/log/" + Prefix + "/part{ID_part}_phyML_done"
    params: time="20:00:00", mem="1G",threads="1"
    shell:
        """
        mkdir -p {output.PathphyML}
        mkdir -p {pathScripts}/log/phyML_output/
        for ID in `cat {input.IDList}`
        do
        phyml --datatype aa --quiet --model LG -o lr --input {input.FilteredAlign}/${{ID}}.rphylip --inputtree {input.TreeByElem}/${{ID}}.nh &> {output.phyMLOutput}
        mv {input.FilteredAlign}/${{ID}}*phyml* {output.PathphyML}
        done
        touch {output.Done} 
        """

rule CombineTrees:
    message: "Merge all phyML resulting tree for RERconverge input"
    input:
        PathphyML = pathResults + "/phyML/" + Prefix + "_part{ID_part}/",
        phyMLDone = pathScripts + "/log/" + Prefix + "/part{ID_part}_phyML_done"
    output:
        CombinedTrees = pathResults + "/phyML/" + Prefix + "_part{ID_part}_CombineTrees.txt",
        Done = pathScripts + "/log/" +   Prefix + "/part{ID_part}_CombineTrees_done"
    shell:
        """
        touch {output.CombinedTrees}
        for file in `ls {input.PathphyML}/*tree*`
        do
	    export ID=$(basename ${{file%.rphylip*}})
	    export tree=`cat ${{file}}`
	    echo -e ${{ID}}"\t"${{tree}} >> {output.CombinedTrees}
        done
        touch {output.Done} 
        """

